"""Common utilities for LLDB scripts in the VSCode/Cursor debugging workflow."""

import json
import os
import pathlib
import sys
from typing import Any

import lldb


# These files are generated by the lldb_launch_and_debug.sh script.
LAUNCH_INFO_PATH = pathlib.Path(".bsp/skbsp_generated/lldb.json")
OUTPUT_BASE_PATH = pathlib.Path(".bsp/skbsp_generated/output_base.txt")


def load_launch_info() -> dict[str, Any]:
    # We exit cleanly as a way to not throw a bunch of
    # errors when the `preLaunchTask` fails. Ideally we wouldn't get here, but
    # `lldb-dap` has a bug where background tasks don't prevent debugging from
    # starting.
    if not LAUNCH_INFO_PATH.exists():
        print("Launch info file not found. Exiting.", file=sys.stderr, flush=True)
        lldb.SBDebugger.Terminate()
        os._exit(0)

    return json.loads(LAUNCH_INFO_PATH.read_text())


def load_output_base() -> str:
    # We exit cleanly as a way to not throw a bunch of
    # errors when the `preLaunchTask` fails. Ideally we wouldn't get here, but
    # `lldb-dap` has a bug where background tasks don't prevent debugging from
    # starting.
    if not OUTPUT_BASE_PATH.exists():
        print("Output base file not found. Exiting.", file=sys.stderr, flush=True)
        lldb.SBDebugger.Terminate()
        os._exit(0)

    return OUTPUT_BASE_PATH.read_text().strip()


def run_command(command: str) -> None:
    print(f"(lldb) {command}", flush=True)
    result = lldb.SBCommandReturnObject()
    lldb.debugger.GetCommandInterpreter().HandleCommand(command, result)
    if result.Succeeded():
        output = result.GetOutput()
        if output:
            print(output, flush=True)
    else:
        output = result.GetError()
        if output:
            print(output, file=sys.stderr, flush=True)
        msg = "Command failed. See above for any error messages."
        raise RuntimeError(msg)
