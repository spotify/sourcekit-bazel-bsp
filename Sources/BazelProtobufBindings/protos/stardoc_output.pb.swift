// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stardoc_output.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Copyright 2019 The Bazel Authors. All rights reserved.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///    http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// Protos for Stardoc data.
///
/// Stardoc collects information about Starlark functions, providers, and rules.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Representation of a Starlark rule attribute type. These generally
/// have a one-to-one correspondence with functions defined at
/// https://bazel.build/rules/lib/toplevel/attr.
public enum StardocOutput_AttributeType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// A special case of STRING; all rules have exactly one implicit
  /// attribute "name" of type NAME.
  case name // = 1
  case int // = 2
  case label // = 3
  case string // = 4
  case stringList // = 5
  case intList // = 6
  case labelList // = 7
  case boolean // = 8
  case labelStringDict // = 9
  case stringDict // = 10
  case stringListDict // = 11
  case output // = 12
  case outputList // = 13
  case labelDictUnary // = 14
  case labelListDict // = 15
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .name
    case 2: self = .int
    case 3: self = .label
    case 4: self = .string
    case 5: self = .stringList
    case 6: self = .intList
    case 7: self = .labelList
    case 8: self = .boolean
    case 9: self = .labelStringDict
    case 10: self = .stringDict
    case 11: self = .stringListDict
    case 12: self = .output
    case 13: self = .outputList
    case 14: self = .labelDictUnary
    case 15: self = .labelListDict
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .name: return 1
    case .int: return 2
    case .label: return 3
    case .string: return 4
    case .stringList: return 5
    case .intList: return 6
    case .labelList: return 7
    case .boolean: return 8
    case .labelStringDict: return 9
    case .stringDict: return 10
    case .stringListDict: return 11
    case .output: return 12
    case .outputList: return 13
    case .labelDictUnary: return 14
    case .labelListDict: return 15
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [StardocOutput_AttributeType] = [
    .unknown,
    .name,
    .int,
    .label,
    .string,
    .stringList,
    .intList,
    .labelList,
    .boolean,
    .labelStringDict,
    .stringDict,
    .stringListDict,
    .output,
    .outputList,
    .labelDictUnary,
    .labelListDict,
  ]

}

/// Representation of the syntactic role of a given function parameter.
public enum StardocOutput_FunctionParamRole: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case paramRoleUnspecified // = 0

  /// An ordinary parameter which may be used as a positional or by keyword.
  case paramRoleOrdinary // = 1

  /// A positional-only parameter; such parameters cannot be defined in pure
  /// Starlark code, but exist in some natively-defined functions.
  case paramRolePositionalOnly // = 2

  /// A keyword-only parameter, i.e. a non-vararg/kwarg parameter that follows
  /// `*` or `*args` in the function's declaration.
  case paramRoleKeywordOnly // = 3

  /// Residual varargs, typically `*args` in the function's declaration.
  case paramRoleVarargs // = 4

  /// Residual keyword arguments, typically `**kwargs` in the function's
  /// declaration.
  case paramRoleKwargs // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .paramRoleUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .paramRoleUnspecified
    case 1: self = .paramRoleOrdinary
    case 2: self = .paramRolePositionalOnly
    case 3: self = .paramRoleKeywordOnly
    case 4: self = .paramRoleVarargs
    case 5: self = .paramRoleKwargs
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .paramRoleUnspecified: return 0
    case .paramRoleOrdinary: return 1
    case .paramRolePositionalOnly: return 2
    case .paramRoleKeywordOnly: return 3
    case .paramRoleVarargs: return 4
    case .paramRoleKwargs: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [StardocOutput_FunctionParamRole] = [
    .paramRoleUnspecified,
    .paramRoleOrdinary,
    .paramRolePositionalOnly,
    .paramRoleKeywordOnly,
    .paramRoleVarargs,
    .paramRoleKwargs,
  ]

}

/// The root output proto of Stardoc. An invocation of Stardoc on a single file
/// will output exactly one instance of this proto, representing all
/// documentation for the input Starlark file.
public struct StardocOutput_ModuleInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ruleInfo: [StardocOutput_RuleInfo] = []

  public var providerInfo: [StardocOutput_ProviderInfo] = []

  public var funcInfo: [StardocOutput_StarlarkFunctionInfo] = []

  public var aspectInfo: [StardocOutput_AspectInfo] = []

  /// The docstring present at the top of the input Starlark file.
  public var moduleDocstring: String = String()

  /// The display form of the label of the module file (as seen from the
  /// starlark_doc_extract or Stardoc target's repo). Unset when there is no
  /// module file (e.g. when the module is a REPL, or in Bazel's internal tests).
  public var file: String = String()

  public var moduleExtensionInfo: [StardocOutput_ModuleExtensionInfo] = []

  public var repositoryRuleInfo: [StardocOutput_RepositoryRuleInfo] = []

  public var macroInfo: [StardocOutput_MacroInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of a Starlark rule definition.
public struct StardocOutput_RuleInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// In Stardoc and starlark_doc_extract output, this is the name under which
  /// the rule is made accessible to a user of this module, including any structs
  /// it is nested in, for example "foo.foo_library".
  ///
  /// In query output, this is the name under which the rule was defined (which
  /// might be a private symbol prefixed with "_").
  public var ruleName: String = String()

  /// The documentation string of the rule.
  public var docString: String = String()

  /// The attributes of the rule.
  public var attribute: [StardocOutput_AttributeInfo] = []

  /// The module where and the name under which the rule was originally declared.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  /// The list of providers that the rule's implementation must return. Unset if
  /// the rule lists no advertised providers.
  public var advertisedProviders: StardocOutput_ProviderNameGroup {
    get {return _advertisedProviders ?? StardocOutput_ProviderNameGroup()}
    set {_advertisedProviders = newValue}
  }
  /// Returns true if `advertisedProviders` has been explicitly set.
  public var hasAdvertisedProviders: Bool {return self._advertisedProviders != nil}
  /// Clears the value of `advertisedProviders`. Subsequent reads from it will return its default value.
  public mutating func clearAdvertisedProviders() {self._advertisedProviders = nil}

  /// True if this is a test rule.
  public var test: Bool = false

  /// True if this is an executable rule.
  ///
  /// Note: if test is true, executable is also true (test rules are implicitly
  /// executable).
  public var executable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
  fileprivate var _advertisedProviders: StardocOutput_ProviderNameGroup? = nil
}

/// Representation of a Starlark symbolic macro definition.
/// Note: symbolic macros (and thus, their documentation format) are an
/// experimental feature gated by the --experimental_enable_first_class_macros
/// flag.
public struct StardocOutput_MacroInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the macro is made accessible to a user of this module,
  /// including any structs it is nested in, for example "foo.foo_library".
  public var macroName: String = String()

  /// The documentation string of the macro.
  public var docString: String = String()

  /// The attributes of the macro.
  public var attribute: [StardocOutput_AttributeInfo] = []

  /// The module where and the name under which the macro was originally
  /// declared.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  /// True if this macro is a rule finalizer.
  public var finalizer: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
}

/// Representation of a Starlark rule, repository rule, or module extension tag
/// attribute definition, comprised of an attribute name, and a schema defined by
/// a call to one of the 'attr' module methods enumerated at
/// https://bazel.build/rules/lib/toplevel/attr.
public struct StardocOutput_AttributeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the attribute.
  public var name: String = String()

  /// The documentation string of the attribute, supplied via the 'doc'
  /// parameter to the schema-creation call.
  public var docString: String = String()

  /// The type of the attribute, defined generally by which function is invoked
  /// in the attr module.
  public var type: StardocOutput_AttributeType = .unknown

  /// If true, all targets of the rule must specify a value for this attribute.
  public var mandatory: Bool = false

  /// The target(s) in this attribute must define all the providers of at least
  /// one of the ProviderNameGroups in this list. If the Attribute Type is not a
  /// label, a label list, or a label-keyed string dictionary, the field will be
  /// left empty. For attributes of a repository rule or a module extension tag,
  /// this attribute is meaningless and may be ignored.
  /// TODO(b/290788853): ensure this field is always empty for attributes of a
  /// repository rule or a module extension tag.
  public var providerNameGroup: [StardocOutput_ProviderNameGroup] = []

  /// The string representation of the default value of this attribute.
  public var defaultValue: String = String()

  /// If true, the attribute is non-configurable.
  public var nonconfigurable: Bool = false

  /// If true, the attribute is defined in Bazel's native code, not in Starlark.
  public var nativelyDefined: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of a set of providers.
public struct StardocOutput_ProviderNameGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The names of the providers.
  ///
  /// This field is only intended for rendering human-readable output.
  /// Please use origin_key (a list of the same length and in the same order as
  /// this field) for cross-references and tooling.
  ///
  /// Note: legacy Stardoc (0.5.x and earlier) is unable to extract the name in
  /// some circumstances (for example, if the provider is nested in a struct),
  /// and in that case, the provider name will be "Unknown Provider".
  public var providerName: [String] = []

  /// A list of unambiguous references to providers, of the same length and in
  /// the same order as the provider_name list.
  ///
  /// For provider symbols, this means modules where and the names under which
  /// the providers were originally declared.
  ///
  /// For legacy struct providers, origin_key.file is unset.
  ///
  /// Note: legacy Stardoc (0.5.x and earlier) does not set this field.
  public var originKey: [StardocOutput_OriginKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of Starlark function definition.
public struct StardocOutput_StarlarkFunctionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the function is made accessible to a user of this
  /// module, including any structs it is nested in, for example
  /// "foo.frobnicate".
  public var functionName: String = String()

  /// The parameters for the function, in the following order:
  /// - positional parameters
  /// - keyword-only parameters
  /// - residual varargs parameter (`*args`)
  /// - residual keyword arguments parameter (`**kwargs`)
  /// This order differs from the order in which parameters are listed in the
  /// function's declaration (where positional parameters and keyword-only
  /// parameters are separated either by `*` or `*args`). The declaration order
  /// can be recovered by looking for the transition from ordinary/positional to
  /// keyword-only.
  public var parameter: [StardocOutput_FunctionParamInfo] = []

  /// The documented description of the function (if specified in the function's
  /// docstring).
  public var docString: String = String()

  /// The return value for the function.
  public var `return`: StardocOutput_FunctionReturnInfo {
    get {return _return ?? StardocOutput_FunctionReturnInfo()}
    set {_return = newValue}
  }
  /// Returns true if ``return`` has been explicitly set.
  public var hasReturn: Bool {return self._return != nil}
  /// Clears the value of ``return``. Subsequent reads from it will return its default value.
  public mutating func clearReturn() {self._return = nil}

  /// The deprecation for the function.
  public var deprecated: StardocOutput_FunctionDeprecationInfo {
    get {return _deprecated ?? StardocOutput_FunctionDeprecationInfo()}
    set {_deprecated = newValue}
  }
  /// Returns true if `deprecated` has been explicitly set.
  public var hasDeprecated: Bool {return self._deprecated != nil}
  /// Clears the value of `deprecated`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecated() {self._deprecated = nil}

  /// The module where and the name under which the function was originally
  /// declared.
  ///
  /// Note: legacy Stardoc (0.5.x and earlier) does not set this field.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _return: StardocOutput_FunctionReturnInfo? = nil
  fileprivate var _deprecated: StardocOutput_FunctionDeprecationInfo? = nil
  fileprivate var _originKey: StardocOutput_OriginKey? = nil
}

/// Representation of a Starlark function parameter definition.
public struct StardocOutput_FunctionParamInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the parameter. This does *not* include the `*` or `**` prefix
  /// for varargs or residual keyword argument parameters.
  public var name: String = String()

  /// The documented description of the parameter (if specified in the function's
  /// docstring).
  public var docString: String = String()

  /// If not an empty string, the default value of the parameter displayed
  /// as a string.
  public var defaultValue: String = String()

  /// If true, the default value is unset and a value is needed for this
  /// parameter. This might be false even if defaultValue is empty in the case of
  /// special parameter such as *args and **kwargs"
  public var mandatory: Bool = false

  /// The parameter's syntactic role.
  public var role: StardocOutput_FunctionParamRole = .paramRoleUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StardocOutput_FunctionReturnInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The documented return value of the function (if specified in the function's
  /// docstring).
  public var docString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct StardocOutput_FunctionDeprecationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The documented deprecation of the function (if specified in the function's
  /// docstring).
  public var docString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of a Starlark provider field definition, comprised of
/// the field name and provider description.
public struct StardocOutput_ProviderFieldInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the field.
  public var name: String = String()

  /// The description of the provider.
  public var docString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of a Starlark provider definition.
public struct StardocOutput_ProviderInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the provider is made accessible to a user of this
  /// module, including any structs it is nested in, for example "foo.FooInfo".
  public var providerName: String = String()

  /// The description of the provider.
  public var docString: String = String()

  /// The fields of the provider.
  public var fieldInfo: [StardocOutput_ProviderFieldInfo] = []

  /// The module where and the name under which the provider was originally
  /// declared.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  /// The provider's init callback.
  public var init_p: StardocOutput_StarlarkFunctionInfo {
    get {return _init_p ?? StardocOutput_StarlarkFunctionInfo()}
    set {_init_p = newValue}
  }
  /// Returns true if `init_p` has been explicitly set.
  public var hasInit_p: Bool {return self._init_p != nil}
  /// Clears the value of `init_p`. Subsequent reads from it will return its default value.
  public mutating func clearInit_p() {self._init_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
  fileprivate var _init_p: StardocOutput_StarlarkFunctionInfo? = nil
}

/// Representation of a Starlark aspect definition.
public struct StardocOutput_AspectInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the aspect is made accessible to a user of this
  /// module, including any structs it is nested in, for example
  /// "foo.foo_aspect".
  public var aspectName: String = String()

  /// The documentation string of the aspect.
  public var docString: String = String()

  /// The rule attributes along which the aspect propagates.
  public var aspectAttribute: [String] = []

  /// The attributes of the aspect.
  public var attribute: [StardocOutput_AttributeInfo] = []

  /// The module where and the name under which the aspect was originally
  /// declared.
  ///
  /// Note: legacy Stardoc (0.5.x and earlier) does not set this field.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
}

/// Representation of a Bazel module extension, i.e. the object returned by
/// calling `module_extension(...)`.
///
/// Note: legacy Stardoc (0.5.x and earlier) does not emit this message.
public struct StardocOutput_ModuleExtensionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the extension is made accessible to a user of this
  /// Starlark module.
  public var extensionName: String = String()

  /// The documentation string of the extension.
  public var docString: String = String()

  /// The tag classes of the extension.
  public var tagClass: [StardocOutput_ModuleExtensionTagClassInfo] = []

  /// The Starlark module where the Bazel module extension was originally
  /// declared; origin_key.name is currently never set.
  /// TODO(arostovtsev): attempt to retrieve the name under which the module
  /// extension was originally declared if it was declared as a global.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
}

/// Representation of a Bazel module extension tag class.
public struct StardocOutput_ModuleExtensionTagClassInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the tag for this tag class.
  public var tagName: String = String()

  /// The documentation string of the tag class.
  public var docString: String = String()

  /// The tag class's attributes.
  public var attribute: [StardocOutput_AttributeInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Representation of a Bazel repository rule, i.e. the object returned by
/// calling `repository_rule(...)`.
///
/// Note: legacy Stardoc (0.5.x and earlier) does not emit this message, instead
/// using RuleInfo.
public struct StardocOutput_RepositoryRuleInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the repository rule is made accessible to a user of
  /// this Starlark module.
  public var ruleName: String = String()

  /// The documentation string of the repository rule.
  public var docString: String = String()

  /// The attributes of the repository rule.
  public var attribute: [StardocOutput_AttributeInfo] = []

  /// Environment variables that this repository rule depends on.
  public var environ: [String] = []

  /// The Starlark module where and the name under which the repository rule was
  /// originally declared.
  public var originKey: StardocOutput_OriginKey {
    get {return _originKey ?? StardocOutput_OriginKey()}
    set {_originKey = newValue}
  }
  /// Returns true if `originKey` has been explicitly set.
  public var hasOriginKey: Bool {return self._originKey != nil}
  /// Clears the value of `originKey`. Subsequent reads from it will return its default value.
  public mutating func clearOriginKey() {self._originKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originKey: StardocOutput_OriginKey? = nil
}

/// Representation of the origin of a rule, provider, aspect, or function.
/// Intended to be used for building unambiguous cross-references: for example,
/// between an element of a ProviderNameGroup required by a rule attribute and
/// its corresponding ProviderInfo.
public struct StardocOutput_OriginKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name under which the entity was originally exported. Unset when the
  /// entity was not exported in its module.
  public var name: String = String()

  /// The display form of the label of the module file in which the entity was
  /// originally declared (as seen from the starlark_doc_extract or Stardoc
  /// target's repo), or "<native>" for Bazel's built-in entities implemented in
  /// Java. Unset when there is no module file (such as for legacy struct
  /// providers, when the module is a REPL, or in Bazel's internal tests).
  public var file: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stardoc_output"

extension StardocOutput_AttributeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NAME"),
    2: .same(proto: "INT"),
    3: .same(proto: "LABEL"),
    4: .same(proto: "STRING"),
    5: .same(proto: "STRING_LIST"),
    6: .same(proto: "INT_LIST"),
    7: .same(proto: "LABEL_LIST"),
    8: .same(proto: "BOOLEAN"),
    9: .same(proto: "LABEL_STRING_DICT"),
    10: .same(proto: "STRING_DICT"),
    11: .same(proto: "STRING_LIST_DICT"),
    12: .same(proto: "OUTPUT"),
    13: .same(proto: "OUTPUT_LIST"),
    14: .same(proto: "LABEL_DICT_UNARY"),
    15: .same(proto: "LABEL_LIST_DICT"),
  ]
}

extension StardocOutput_FunctionParamRole: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARAM_ROLE_UNSPECIFIED"),
    1: .same(proto: "PARAM_ROLE_ORDINARY"),
    2: .same(proto: "PARAM_ROLE_POSITIONAL_ONLY"),
    3: .same(proto: "PARAM_ROLE_KEYWORD_ONLY"),
    4: .same(proto: "PARAM_ROLE_VARARGS"),
    5: .same(proto: "PARAM_ROLE_KWARGS"),
  ]
}

extension StardocOutput_ModuleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rule_info"),
    2: .standard(proto: "provider_info"),
    3: .standard(proto: "func_info"),
    4: .standard(proto: "aspect_info"),
    5: .standard(proto: "module_docstring"),
    6: .same(proto: "file"),
    7: .standard(proto: "module_extension_info"),
    8: .standard(proto: "repository_rule_info"),
    9: .standard(proto: "macro_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ruleInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.providerInfo) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.funcInfo) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.aspectInfo) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.moduleDocstring) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.moduleExtensionInfo) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.repositoryRuleInfo) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.macroInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ruleInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ruleInfo, fieldNumber: 1)
    }
    if !self.providerInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providerInfo, fieldNumber: 2)
    }
    if !self.funcInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funcInfo, fieldNumber: 3)
    }
    if !self.aspectInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aspectInfo, fieldNumber: 4)
    }
    if !self.moduleDocstring.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleDocstring, fieldNumber: 5)
    }
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 6)
    }
    if !self.moduleExtensionInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.moduleExtensionInfo, fieldNumber: 7)
    }
    if !self.repositoryRuleInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.repositoryRuleInfo, fieldNumber: 8)
    }
    if !self.macroInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.macroInfo, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ModuleInfo, rhs: StardocOutput_ModuleInfo) -> Bool {
    if lhs.ruleInfo != rhs.ruleInfo {return false}
    if lhs.providerInfo != rhs.providerInfo {return false}
    if lhs.funcInfo != rhs.funcInfo {return false}
    if lhs.aspectInfo != rhs.aspectInfo {return false}
    if lhs.moduleDocstring != rhs.moduleDocstring {return false}
    if lhs.file != rhs.file {return false}
    if lhs.moduleExtensionInfo != rhs.moduleExtensionInfo {return false}
    if lhs.repositoryRuleInfo != rhs.repositoryRuleInfo {return false}
    if lhs.macroInfo != rhs.macroInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_RuleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rule_name"),
    2: .standard(proto: "doc_string"),
    3: .same(proto: "attribute"),
    4: .standard(proto: "origin_key"),
    5: .standard(proto: "advertised_providers"),
    6: .same(proto: "test"),
    7: .same(proto: "executable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ruleName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._advertisedProviders) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.test) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.executable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ruleName.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 3)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._advertisedProviders {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.test != false {
      try visitor.visitSingularBoolField(value: self.test, fieldNumber: 6)
    }
    if self.executable != false {
      try visitor.visitSingularBoolField(value: self.executable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_RuleInfo, rhs: StardocOutput_RuleInfo) -> Bool {
    if lhs.ruleName != rhs.ruleName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs._advertisedProviders != rhs._advertisedProviders {return false}
    if lhs.test != rhs.test {return false}
    if lhs.executable != rhs.executable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_MacroInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MacroInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "macro_name"),
    2: .standard(proto: "doc_string"),
    3: .same(proto: "attribute"),
    4: .standard(proto: "origin_key"),
    5: .same(proto: "finalizer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.macroName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.finalizer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.macroName.isEmpty {
      try visitor.visitSingularStringField(value: self.macroName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 3)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.finalizer != false {
      try visitor.visitSingularBoolField(value: self.finalizer, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_MacroInfo, rhs: StardocOutput_MacroInfo) -> Bool {
    if lhs.macroName != rhs.macroName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs.finalizer != rhs.finalizer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_AttributeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "doc_string"),
    3: .same(proto: "type"),
    4: .same(proto: "mandatory"),
    5: .standard(proto: "provider_name_group"),
    6: .standard(proto: "default_value"),
    7: .same(proto: "nonconfigurable"),
    8: .standard(proto: "natively_defined"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.mandatory) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.providerNameGroup) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.nonconfigurable) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.nativelyDefined) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.mandatory != false {
      try visitor.visitSingularBoolField(value: self.mandatory, fieldNumber: 4)
    }
    if !self.providerNameGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.providerNameGroup, fieldNumber: 5)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 6)
    }
    if self.nonconfigurable != false {
      try visitor.visitSingularBoolField(value: self.nonconfigurable, fieldNumber: 7)
    }
    if self.nativelyDefined != false {
      try visitor.visitSingularBoolField(value: self.nativelyDefined, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_AttributeInfo, rhs: StardocOutput_AttributeInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mandatory != rhs.mandatory {return false}
    if lhs.providerNameGroup != rhs.providerNameGroup {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.nonconfigurable != rhs.nonconfigurable {return false}
    if lhs.nativelyDefined != rhs.nativelyDefined {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_ProviderNameGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProviderNameGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_name"),
    2: .standard(proto: "origin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.providerName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.originKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providerName.isEmpty {
      try visitor.visitRepeatedStringField(value: self.providerName, fieldNumber: 1)
    }
    if !self.originKey.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.originKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ProviderNameGroup, rhs: StardocOutput_ProviderNameGroup) -> Bool {
    if lhs.providerName != rhs.providerName {return false}
    if lhs.originKey != rhs.originKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_StarlarkFunctionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StarlarkFunctionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .same(proto: "parameter"),
    3: .standard(proto: "doc_string"),
    4: .same(proto: "return"),
    5: .same(proto: "deprecated"),
    6: .standard(proto: "origin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parameter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._return) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deprecated) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 1)
    }
    if !self.parameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameter, fieldNumber: 2)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 3)
    }
    try { if let v = self._return {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deprecated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_StarlarkFunctionInfo, rhs: StardocOutput_StarlarkFunctionInfo) -> Bool {
    if lhs.functionName != rhs.functionName {return false}
    if lhs.parameter != rhs.parameter {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs._return != rhs._return {return false}
    if lhs._deprecated != rhs._deprecated {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_FunctionParamInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionParamInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "doc_string"),
    3: .standard(proto: "default_value"),
    4: .same(proto: "mandatory"),
    5: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.mandatory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 3)
    }
    if self.mandatory != false {
      try visitor.visitSingularBoolField(value: self.mandatory, fieldNumber: 4)
    }
    if self.role != .paramRoleUnspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_FunctionParamInfo, rhs: StardocOutput_FunctionParamInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.mandatory != rhs.mandatory {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_FunctionReturnInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionReturnInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "doc_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_FunctionReturnInfo, rhs: StardocOutput_FunctionReturnInfo) -> Bool {
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_FunctionDeprecationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionDeprecationInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "doc_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_FunctionDeprecationInfo, rhs: StardocOutput_FunctionDeprecationInfo) -> Bool {
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_ProviderFieldInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProviderFieldInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "doc_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ProviderFieldInfo, rhs: StardocOutput_ProviderFieldInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_ProviderInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProviderInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_name"),
    2: .standard(proto: "doc_string"),
    3: .standard(proto: "field_info"),
    4: .standard(proto: "origin_key"),
    5: .same(proto: "init"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.providerName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fieldInfo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._init_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.providerName.isEmpty {
      try visitor.visitSingularStringField(value: self.providerName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.fieldInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldInfo, fieldNumber: 3)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._init_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ProviderInfo, rhs: StardocOutput_ProviderInfo) -> Bool {
    if lhs.providerName != rhs.providerName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.fieldInfo != rhs.fieldInfo {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs._init_p != rhs._init_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_AspectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AspectInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aspect_name"),
    2: .standard(proto: "doc_string"),
    3: .standard(proto: "aspect_attribute"),
    4: .same(proto: "attribute"),
    5: .standard(proto: "origin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.aspectName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.aspectAttribute) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.aspectName.isEmpty {
      try visitor.visitSingularStringField(value: self.aspectName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.aspectAttribute.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aspectAttribute, fieldNumber: 3)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 4)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_AspectInfo, rhs: StardocOutput_AspectInfo) -> Bool {
    if lhs.aspectName != rhs.aspectName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.aspectAttribute != rhs.aspectAttribute {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_ModuleExtensionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleExtensionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "extension_name"),
    2: .standard(proto: "doc_string"),
    3: .standard(proto: "tag_class"),
    4: .standard(proto: "origin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.extensionName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tagClass) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.extensionName.isEmpty {
      try visitor.visitSingularStringField(value: self.extensionName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.tagClass.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tagClass, fieldNumber: 3)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ModuleExtensionInfo, rhs: StardocOutput_ModuleExtensionInfo) -> Bool {
    if lhs.extensionName != rhs.extensionName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.tagClass != rhs.tagClass {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_ModuleExtensionTagClassInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModuleExtensionTagClassInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_name"),
    2: .standard(proto: "doc_string"),
    3: .same(proto: "attribute"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tagName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagName.isEmpty {
      try visitor.visitSingularStringField(value: self.tagName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_ModuleExtensionTagClassInfo, rhs: StardocOutput_ModuleExtensionTagClassInfo) -> Bool {
    if lhs.tagName != rhs.tagName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_RepositoryRuleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RepositoryRuleInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rule_name"),
    2: .standard(proto: "doc_string"),
    3: .same(proto: "attribute"),
    4: .same(proto: "environ"),
    5: .standard(proto: "origin_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ruleName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.docString) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.environ) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._originKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ruleName.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleName, fieldNumber: 1)
    }
    if !self.docString.isEmpty {
      try visitor.visitSingularStringField(value: self.docString, fieldNumber: 2)
    }
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 3)
    }
    if !self.environ.isEmpty {
      try visitor.visitRepeatedStringField(value: self.environ, fieldNumber: 4)
    }
    try { if let v = self._originKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_RepositoryRuleInfo, rhs: StardocOutput_RepositoryRuleInfo) -> Bool {
    if lhs.ruleName != rhs.ruleName {return false}
    if lhs.docString != rhs.docString {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.environ != rhs.environ {return false}
    if lhs._originKey != rhs._originKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StardocOutput_OriginKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OriginKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "file"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.file) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: StardocOutput_OriginKey, rhs: StardocOutput_OriginKey) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
